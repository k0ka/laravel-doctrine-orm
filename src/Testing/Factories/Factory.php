<?php

namespace LaravelDoctrine\ORM\Testing\Factories;

use Closure;
use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\ORM\Mapping\ClassMetadata;
use Doctrine\Persistence\ManagerRegistry;
use Faker\Generator;
use Illuminate\Container\Container;
use Illuminate\Contracts\Foundation\Application;
use Illuminate\Database\Eloquent\Factories\CrossJoinSequence;
use Illuminate\Database\Eloquent\Factories\Sequence;
use Illuminate\Support\Collection;
use Illuminate\Support\Str;
use LaravelDoctrine\ORM\Testing\SimpleHydrator;
use Throwable;

/**
 * @template TModel
 */
abstract class Factory
{
    /**
     * The name of the factory's corresponding model.
     *
     * @var class-string<TModel>
     */
    protected $class;

    /**
     * The number of models that should be generated.
     *
     * @var int|null
     */
    protected $count;

    /**
     * The state transformations that will be applied to the model.
     *
     * @var \Illuminate\Support\Collection
     */
    protected $states;

    /**
     * The "after making" callbacks that will be applied to the model.
     *
     * @var \Illuminate\Support\Collection
     */
    protected $afterMaking;

    /**
     * The "after creating" callbacks that will be applied to the model.
     *
     * @var \Illuminate\Support\Collection
     */
    protected $afterCreating;

    /**
     * The current Faker instance.
     *
     * @var \Faker\Generator
     */
    protected $faker;

    /**
     * @var ManagerRegistry
     */
    protected ManagerRegistry $registry;

    /**
     * The default namespace where factories reside.
     *
     * @var string
     */
    protected static $namespace = 'Database\\Factories\\';

    /**
     * The default model name resolver.
     *
     * @var callable
     */
    protected static $modelNameResolver;

    /**
     * The factory name resolver.
     *
     * @var callable
     */
    protected static $factoryNameResolver;

    /**
     * Create a new factory instance.
     *
     * @param int|null $count
     * @param \Illuminate\Support\Collection|null $states
     * @param \Illuminate\Support\Collection|null $afterMaking
     * @param \Illuminate\Support\Collection|null $afterCreating
     * @return void
     */
    public function __construct(
        ?int        $count = null,
        ?Collection $states = null,
        ?Collection $afterMaking = null,
        ?Collection $afterCreating = null
    ) {
        $this->count = $count;
        $this->states = $states ?? new Collection;
        $this->afterMaking = $afterMaking ?? new Collection;
        $this->afterCreating = $afterCreating ?? new Collection;
        $this->faker = $this->withFaker();
        $this->registry = Container::getInstance()->make(ManagerRegistry::class);
    }

    /**
     * Define the model's default state.
     *
     * @return array<string, mixed>
     */
    abstract public function definition();

    /**
     * Get a new factory instance for the given attributes.
     *
     * @param  (callable(array<string, mixed>): array<string, mixed>)|array<string, mixed>  $attributes
     * @return static
     */
    public static function new($attributes = [])
    {
        return (new static)->state($attributes)->configure();
    }

    /**
     * Get a new factory instance for the given number of models.
     *
     * @param int $count
     * @return static
     */
    public static function times(int $count)
    {
        return static::new()->count($count);
    }

    /**
     * Configure the factory.
     *
     * @return $this
     */
    public function configure()
    {
        return $this;
    }

    /**
     * Get the raw attributes generated by the factory.
     *
     * @param  (callable(array<string, mixed>): array<string, mixed>)|array<string, mixed>  $attributes
     * @param object|null $parent
     * @return array<int|string, mixed>
     */
    public function raw($attributes = [], ?object $parent = null)
    {
        if ($this->count === null) {
            return $this->state($attributes)->getExpandedAttributes($parent);
        }

        return array_map(function () use ($attributes, $parent) {
            return $this->state($attributes)->getExpandedAttributes($parent);
        }, range(1, $this->count));
    }

    /**
     * Create a single model and persist it to the database.
     *
     * @param  (callable(array<string, mixed>): array<string, mixed>)|array<string, mixed>  $attributes
     * @return TModel
     */
    public function createOne($attributes = [])
    {
        return $this->count(null)->create($attributes);
    }

    /**
     * Create a collection of models and persist them to the database.
     *
     * @param iterable<int, array<string, mixed>> $records
     * @return array<TModel>
     */
    public function createMany(iterable $records): array
    {
        $result = [];
        foreach ($records as $record){
            $result[] = $this->state($record)->create();
        }
        return $result;
    }

    /**
     * Create a collection of models and persist them to the database.
     *
     * @param  (callable(array<string, mixed>): array<string, mixed>)|array<string, mixed>  $attributes
     * @param object|null $parent
     * @return TModel|array<TModel>
     */
    public function create($attributes = [], ?object $parent = null)
    {
        if (!empty($attributes)) {
            return $this->state($attributes)->create([], $parent);
        }

        $results = $this->make($attributes, $parent);

        if (is_array($results)) {
            $this->store($results);
            $this->callAfterCreating($results, $parent);
        } else {
            $this->store([$results]);
            $this->callAfterCreating([$results], $parent);
        }

        return $results;
    }

    /**
     * Create a callback that persists a model in the database when invoked.
     *
     * @param array<string, mixed> $attributes
     * @param object|null $parent
     * @return \Closure(): (TModel|array<TModel>)
     */
    public function lazy(array $attributes = [], ?object $parent = null)
    {
        return fn() => $this->create($attributes, $parent);
    }

    /**
     * Stores results in ORM.
     *
     * @param array<TModel> $results
     * @return void
     */
    protected function store(array $results): void
    {
        $manager = $this->registry->getManagerForClass($this->className());
        foreach ($results as $result){
            $manager->persist($result);
        }
        $manager->flush();
    }

    /**
     * Make a single instance of the model.
     *
     * @param  (callable(array<string, mixed>): array<string, mixed>)|array<string, mixed>  $attributes
     * @return TModel
     */
    public function makeOne($attributes = []): object
    {
        return $this->count(null)->make($attributes);
    }

    /**
     * Create a collection of models.
     *
     * @param  (callable(array<string, mixed>): array<string, mixed>)|array<string, mixed>  $attributes
     * @param object|null $parent
     * @return TModel|array<TModel>
     */
    public function make($attributes = [], ?object $parent = null)
    {
        if (!empty($attributes)) {
            return $this->state($attributes)->make([], $parent);
        }

        if ($this->count === null) {
            return tap($this->makeInstance($parent), function ($instance) {
                $this->callAfterMaking([$instance]);
            });
        }

        if ($this->count < 1) {
            return [];
        }

        $instances = array_map(function () use ($parent) {
            return $this->makeInstance($parent);
        }, range(1, $this->count));

        $this->callAfterMaking($instances);

        return $instances;
    }

    /**
     * Make an instance of the model with the given attributes.
     *
     * @param object|null $parent
     * @return TModel
     */
    protected function makeInstance(?object $parent): object
    {
        $attributes = $this->getExpandedAttributes($parent);

        /** @var ClassMetadata $metadata */
        $metadata = $this->registry
            ->getManagerForClass($this->className())
            ->getClassMetadata($this->className());

        $toManyRelations = (new Collection($metadata->getAssociationMappings()))
            ->keys()
            ->filter(function ($association) use ($metadata) {
                return $metadata->isCollectionValuedAssociation($association);
            })
            ->mapWithKeys(function ($association) {
                return [$association => new ArrayCollection];
            });

        return SimpleHydrator::hydrate(
            $this->className(),
            array_merge($toManyRelations->all(), $attributes)
        );
    }

    /**
     * Get a raw attributes array for the model.
     *
     * @param object|null $parent
     * @return array
     */
    protected function getExpandedAttributes(?object $parent): array
    {
        return $this->expandAttributes($this->getRawAttributes($parent));
    }

    /**
     * Get the raw attributes for the model as an array.
     *
     * @param object|null $parent
     * @return array
     */
    protected function getRawAttributes(?object $parent): array
    {
        return $this->states->reduce(function ($carry, $state) use ($parent) {
            if ($state instanceof Closure) {
                $state = $state->bindTo($this);
            }

            return array_merge($carry, $state($carry, $parent));
        }, $this->definition());
    }

    /**
     * Expand all attributes to their underlying values.
     *
     * @param array $definition
     * @return array
     */
    protected function expandAttributes(array $definition): array
    {
        return collect($definition)
            ->map($evaluateRelations = function ($attribute) {
                if (is_array($attribute) || $attribute instanceof \Traversable) {
                    foreach ($attribute as $e) {
                        if (is_object($e)) {
                            $this->registry
                                ->getManagerForClass(get_class($e))
                                ->persist($e);
                        }
                    }
                } elseif (is_object($attribute) && !($attribute instanceof \Closure)) {
                    $this->registry
                        ->getManagerForClass(get_class($attribute))
                        ->persist($attribute);
                }

                return $attribute;
            })
            ->map(function ($attribute, $key) use (&$definition, $evaluateRelations) {
                if (is_callable($attribute) && !is_string($attribute) && !is_array($attribute)) {
                    $attribute = $attribute($definition);
                }

                $attribute = $evaluateRelations($attribute);

                $definition[$key] = $attribute;

                return $attribute;
            })
            ->all();
    }

    /**
     * Add a new state transformation to the model definition.
     *
     * @param  (callable(array<string, mixed>, TModel|null=): array<string, mixed>)|array<string, mixed>  $state
     * @return static
     */
    public function state($state): static
    {
        return $this->newInstance([
            'states' => $this->states->concat([
                is_callable($state) ? $state : function () use ($state) {
                    return $state;
                },
            ]),
        ]);
    }

    /**
     * Set a single model attribute.
     *
     * @param string|int $key
     * @param mixed $value
     * @return static
     */
    public function set($key, $value): static
    {
        return $this->state([$key => $value]);
    }

    /**
     * Add a new sequenced state transformation to the model definition.
     *
     * @param array $sequence
     * @return static
     */
    public function sequence(...$sequence): static
    {
        return $this->state(new Sequence(...$sequence));
    }

    /**
     * Add a new sequenced state transformation to the model definition and update the pending creation count to the size of the sequence.
     *
     * @param array $sequence
     * @return static
     */
    public function forEachSequence(...$sequence): static
    {
        return $this->state(new Sequence(...$sequence))->count(count($sequence));
    }

    /**
     * Add a new cross joined sequenced state transformation to the model definition.
     *
     * @param array $sequence
     * @return static
     */
    public function crossJoinSequence(...$sequence): static
    {
        return $this->state(new CrossJoinSequence(...$sequence));
    }

    /**
     * Add a new "after making" callback to the model definition.
     *
     * @param \Closure(TModel): mixed  $callback
     * @return static
     */
    public function afterMaking(Closure $callback): static
    {
        return $this->newInstance(['afterMaking' => $this->afterMaking->concat([$callback])]);
    }

    /**
     * Add a new "after creating" callback to the model definition.
     *
     * @param \Closure(TModel): mixed  $callback
     * @return static
     */
    public function afterCreating(Closure $callback): static
    {
        return $this->newInstance(['afterCreating' => $this->afterCreating->concat([$callback])]);
    }

    /**
     * Call the "after making" callbacks for the given model instances.
     *
     * @param array<TModel> $instances
     * @return void
     */
    protected function callAfterMaking(array $instances): void
    {
        foreach ($instances as $instance) {
            $this->afterMaking->each(function ($callback) use ($instance) {
                $callback($instance);
            });
        }
    }

    /**
     * Call the "after creating" callbacks for the given model instances.
     *
     * @param array<TModel> $instances
     * @param object|null $parent
     * @return void
     */
    protected function callAfterCreating(array $instances, ?object $parent = null): void
    {
        foreach ($instances as $instance){
            $this->afterCreating->each(function ($callback) use ($instance, $parent) {
                $callback($instance, $parent);
            });
        }
    }

    /**
     * Specify how many models should be generated.
     *
     * @param int|null $count
     * @return static
     */
    public function count(?int $count): static
    {
        return $this->newInstance(['count' => $count]);
    }

    /**
     * Create a new instance of the factory builder with the given mutated properties.
     *
     * @param array $arguments
     * @return static
     */
    protected function newInstance(array $arguments = []): static
    {
        return new static(...array_values(array_merge([
            'count' => $this->count,
            'states' => $this->states,
            'afterMaking' => $this->afterMaking,
            'afterCreating' => $this->afterCreating,
        ], $arguments)));
    }

    /**
     * Get the name of the class that is generated by the factory.
     *
     * @return class-string<TModel>
     */
    public function className(): string
    {
        $resolver = static::$modelNameResolver ?? function (self $factory) {
                $namespacedFactoryBasename = Str::replaceLast(
                    'Factory', '', Str::replaceFirst(static::$namespace, '', get_class($factory))
                );

                $factoryBasename = Str::replaceLast('Factory', '', class_basename($factory));

                $appNamespace = static::appNamespace();

                return class_exists($appNamespace . 'Entities\\' . $namespacedFactoryBasename)
                    ? $appNamespace . 'Entities\\' . $namespacedFactoryBasename
                    : $appNamespace . $factoryBasename;
            };

        return $this->class ?? $resolver($this);
    }

    /**
     * Specify the callback that should be invoked to guess model names based on factory names.
     *
     * @param callable(self): class-string<object> $callback
     * @return void
     */
    public static function guessModelNamesUsing(callable $callback): void
    {
        static::$modelNameResolver = $callback;
    }

    /**
     * Specify the default namespace that contains the application's model factories.
     *
     * @param string $namespace
     * @return void
     */
    public static function useNamespace(string $namespace): void
    {
        static::$namespace = $namespace;
    }

    /**
     * Get a new factory instance for the given model name.
     *
     * @param class-string<object> $modelName
     * @return \Illuminate\Database\Eloquent\Factories\Factory
     */
    public static function factoryForModel(string $modelName)
    {
        $factory = static::resolveFactoryName($modelName);

        return $factory::new();
    }

    /**
     * Specify the callback that should be invoked to guess factory names based on dynamic relationship names.
     *
     * @param callable(class-string<\Illuminate\Database\Eloquent\Model>): class-string<\Illuminate\Database\Eloquent\Factories\Factory> $callback
     * @return void
     */
    public static function guessFactoryNamesUsing(callable $callback)
    {
        static::$factoryNameResolver = $callback;
    }

    /**
     * Get a new Faker instance.
     *
     * @return \Faker\Generator
     */
    protected function withFaker()
    {
        return Container::getInstance()->make(Generator::class);
    }

    /**
     * Get the factory name for the given model name.
     *
     * @param class-string<\Illuminate\Database\Eloquent\Model> $modelName
     * @return class-string<\Illuminate\Database\Eloquent\Factories\Factory>
     */
    public static function resolveFactoryName(string $modelName)
    {
        $resolver = static::$factoryNameResolver ?? function (string $modelName) {
                $appNamespace = static::appNamespace();

                $modelName = Str::startsWith($modelName, $appNamespace . 'Entities\\')
                    ? Str::after($modelName, $appNamespace . 'Entities\\')
                    : Str::after($modelName, $appNamespace);

                return static::$namespace . $modelName . 'Factory';
            };

        return $resolver($modelName);
    }

    /**
     * Get the application namespace for the application.
     *
     * @return string
     */
    protected static function appNamespace()
    {
        try {
            return Container::getInstance()
                ->make(Application::class)
                ->getNamespace();
        } catch (Throwable $e) {
            return 'App\\';
        }
    }
}
